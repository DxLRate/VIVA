**********************  FCFS ALGO *******************
#include<stdio.h>
int main()
{
    int  p[10],at[10],bt[10],ct[10],tat[10],wt[10],i,j,temp=0,n;
    float awt=0,atat=0;
    printf("enter no of proccess you want:");
    scanf("%d",&n);
    printf("enter %d process:",n);
    for(i=0;i<n;i++)
    {
    scanf("%d",&p[i]);
    }
    printf("enter %d arrival time:",n);
    for(i=0;i<n;i++)
    {
    scanf("%d",&at[i]);
    }
    printf("enter %d burst time:",n);
    for(i=0;i<n;i++)
    {
    scanf("%d",&bt[i]);
    }
    // sorting at,bt, and process according to at
    for(i=0;i<n;i++)
    {
     for(j=0;j<(n-i);j++)
    {
      if(at[j]>at[j+1])
     {
        temp=p[j+1];
        p[j+1]=p[j];
        p[j]=temp;
        temp=at[j+1];
        at[j+1]=at[j];
        at[j]=temp;
        temp=bt[j+1];
        bt[j+1]=bt[j];
        bt[j]=temp;
      }
     }
    }
    /* calculating 1st ct */
    ct[0]=at[0]+bt[0];
    /* calculating 2 to n ct */
    for(i=1;i<n;i++)
    {  
      //when proess is ideal in between i and i+1
      temp=0;
     if(ct[i-1]<at[i])
     {
        temp=at[i]-ct[i-1];
     }
     ct[i]=ct[i-1]+bt[i]+temp;
    }
    /* calculating tat and wt */
    printf("\np\t A.T\t B.T\t C.T\t TAT\t WT");
    for(i=0;i<n;i++)
    {
    tat[i]=ct[i]-at[i];
    wt[i]=tat[i]-bt[i];
    atat+=tat[i];
    awt+=wt[i];
    }
    atat=atat/n;
    awt=awt/n;
    for(i=0;i<n;i++)
    {
      printf("\nP%d\t %d\t %d\t %d \t %d \t %d",p[i],at[i],bt[i],ct[i],tat[i],wt[i]);
    }
    printf("\naverage turnaround time is %f",atat);

    printf("\naverage wating timme is %f",awt);
    return 0;
}

****************  SJF ALGO  ********************
#include<stdio.h>
#include<conio.h>
#include<stdlib.h>
void swap(int *x, int *y)
{
    int temp=*x;
    *x=*y;
    *y=temp;
}
void sortat(int p[], int at[], int bt[], int n)
{
  int i, j;
  for(i=0;i<n;i++)
  {
      for(j=i+1;j<n;j++)
      {   /* sort the process having less arrival*/
	  if(at[i]>at[j])
	  { 
	        swap(&p[i], &p[j]);
		swap(&at[i], &at[j]);
		swap(&bt[i], &bt[j]);
	   }
           /* if two processes have the same arrival time than sort them having less burst time */
	   else if(at[i]==at[j])
	   {
	      if(bt[i]>bt[j])
                 swap(&p[i], &p[j]);
                 swap(&at[i], &at[j]);
                 swap(&bt[i], &bt[j]);
	   }
       }
  }
}
/* calculate turnaround time and waiting time */
void tatwt( int ct[], int at[], int bt[], int tat[], int wt[], int n)
{
   int i;
   for(i=0;i<n;i++)
   {
	tat[i]=ct[i]-at[i];
	wt[i]=tat[i]-bt[i];
   }
}
int main()
{
  int *p, *at, *bt, *tat, *wt, *ct, pos, i, j, min=1000, n;
  float awt=0, atat=0;
  printf("\nenter the number of process: ");
  scanf("%d", &n);
  p=(int*)malloc(n*sizeof(int));
  at=(int*)malloc(n*sizeof(int));
  bt=(int*)malloc(n*sizeof(int));
  ct=(int*)malloc(n*sizeof(int));
  wt=(int*)malloc(n*sizeof(int));
  tat=(int*)malloc(n*sizeof(int));
  printf("enter the process : ");
  for(i=0;i<n;i++)
  {
	scanf("%d",&p[i]);
  }
  printf("enter the arrival time : ");
  for(i=0;i<n;i++)
  {
	scanf("%d",&at[i]);
  }
  printf("enter the burst time : ");
  for(i=0;i<n;i++)
  {
	scanf("%d",&bt[i]);
  }
  sortat(p, at, bt, n);
  ct[0]=at[0] + bt[0];
  for(i=1; i<n; i++)
  {
	for(j=i; j<n; j++)
	{
	    if(at[j]<=ct[i-1])
	   {
              if(bt[j]<min)
              {
                 min=bt[j];
                 pos=j;
              }
	   }
	}
   /*  when you get less burst time process, swap p, at, bt at position 2,
    and when getting 2nd less burst time swap at position 3rd and so on.  */
    swap(&p[i], &p[pos]);
    swap(&at[i], &at[pos]);
    swap(&bt[i], &bt[pos]);
    min=1000;
    ct[i]=ct[i-1]+bt[i];
  }
  tatwt(ct, at, bt, tat, wt, n);
  printf("\np\t at\t bt\t ct\t tat\t wt"); 
  for(i=0;i<n;i++)
  {
    printf("\n%d\t %d\t %d\t %d\t %d\t %d",p[i], at[i], bt[i], ct[i], tat[i], wt[i]);
  }
  for(i=0;i<n;i++)
  { 
    atat+=tat[i];
    awt+=wt[i];
  }
  // average turnaround time and average waiting time
  atat=atat/n;
  awt=awt/n;
  printf("\n avg tat=%.2f and avg wt=%.2f",atat, awt); 
  return 0;
}

******************  SRTF ALGO  **********************

#include <iostream>
#include <algorithm>
#include <iomanip>
#include <climits>
using namespace std;
struct process_struct
{
 int pid;
 int at;
 int bt;
 int ct,wt,tat,rt,start_time;
}ps[100];
int main()
{
 
 int n;
 float bt_remaining[100];
 bool is_completed[100]={false},is_first_process=true;
 int current_time = 0;
 int completed = 0;; 
 float sum_tat=0,sum_wt=0,sum_rt=0,total_idle_time=0,length_cycle,prev=0;
 float cpu_utilization;
 int max_completion_time,min_arrival_time;
 
 cout << fixed << setprecision(2);
 cout<<"Enter total number of processes: ";
 cin>>n;
 for(int i=0;i<n;i++)
 {
 cout<<"\nEnter Process " <<i+1<< " Arrival Time: ";
 cin >> ps[i].at;
 ps[i].pid=i;
 }
 
 for(int i=0;i<n;i++)
 {
 cout<<"\nEnter Process " <<i+1<< " Burst Time: ";
 cin >> ps[i].bt;
 bt_remaining[i]= ps[i].bt;
 }
 
 
 while(completed!=n)
 {
 //find process with min. burst time in ready queue at current time
 int min_index = -1;
 int minimum = INT_MAX;
 for(int i = 0; i < n; i++) {
 if(ps[i].at <= current_time && is_completed[i] == false) {
 if(bt_remaining[i] < minimum) {
 minimum = bt_remaining[i];;
 min_index = i;
 }
 if(bt_remaining[i]== minimum) {
 if(ps[i].at < ps[min_index].at) {
 minimum= bt_remaining[i];;
 min_index = i;
 }
 }
 }
 }
 
 if(min_index==-1)
 {
 current_time++;
 }
 else
 {
 if(bt_remaining[min_index] == ps[min_index].bt)
 {
 ps[min_index].start_time = current_time;
 total_idle_time += (is_first_process==true) ? 0 : 
(ps[min_index].start_time - prev);
 is_first_process=false;
 }
 bt_remaining[min_index] -= 1;
 current_time++; 
 prev=current_time;
 if(bt_remaining[min_index] == 0)
 {
 ps[min_index].ct = current_time;
 ps[min_index].tat = ps[min_index].ct - ps[min_index].at;
 ps[min_index].wt= ps[min_index].tat - ps[min_index].bt;
 ps[min_index].rt = ps[min_index].start_time - ps[min_index].at;
 
 
 sum_tat +=ps[min_index].tat;
 sum_wt += ps[min_index].wt;
 sum_rt += ps[min_index].rt;
 completed++;
 is_completed[min_index]=true; 
 
 
 }
 }
 }
 //Calculate Length of Process completion cycle
 max_completion_time = INT_MIN;
 min_arrival_time = INT_MAX;
 for(int i=0;i<n;i++)
 {
 max_completion_time = max(max_completion_time,ps[i].ct);
 min_arrival_time = min(min_arrival_time,ps[i].at);
 }
 length_cycle = max_completion_time - min_arrival_time;
 
 //Output
 cout<<"\nProcess No.\tAT\tCPU Burst Time\tCT\tTAT\tWT\tRT\n";
 for(int i=0;i<n;i++)
 
cout<<i+1<<"\t\t"<<ps[i].at<<"\t"<<ps[i].bt<<"\t\t"<<ps[i].ct<<"\t"<<ps[i].tat<<"\t"<<ps[i].wt<<"\t"<<ps[i].rt<<endl;
 cout<<endl; 
 
 cpu_utilization = (float)(length_cycle - total_idle_time)/ length_cycle;
 cout<<"\nAverage Turn Around time= "<< (float)sum_tat/n;
 cout<<"\nAverage Waiting Time= "<<(float)sum_wt/n;
 cout<<"\nAverage Response Time= "<<(float)sum_rt/n; 
 cout<<"\nThroughput= "<<n/(float)length_cycle;
 cout<<"\nCPU Utilization(Percentage)= " << cpu_utilization*100;
 return 0;
}

**********************  ROUND ROBIN ALGO *****************

#include <stdio.h>
 
int main()
{
   int i, total = 0, x, limit, counter = 0, t_quantum;
   int wait_time = 0, turnaround_time = 0, arrival_time[10], burst_time[10], temp[10];
 
   float average_wait_time, average_turnaround_time;
 
   printf("\nEnter Total Number of Processes: ");
   scanf("%d", &limit);
   x = limit;
 
   for (i = 0; i < limit; i++)
   {
      printf("\nProvide the details for Process[%d]\n", i + 1);
      printf("Arrival Time:\t");
      scanf("%d", &arrival_time[i]);
      printf("Burst Time:\t");
      scanf("%d", &burst_time[i]);
      temp[i] = burst_time[i];
   }
 
   printf("\nEnter Time Quantum:\t");
   scanf("%d", &t_quantum);
 
   printf("\nProcess ID\t\tBurst Time\t Turnaround Time\t Waiting Time\n");
   for (total = 0, i = 0; x != 0;)
   {
      if (temp[i] <= t_quantum && temp[i] > 0)
      {
         total = total + temp[i];
         temp[i] = 0;
         counter = 1;
      }
      else if (temp[i] > 0)
      {
         temp[i] = temp[i] - t_quantum;
         total = total + t_quantum;
      }
 
      if (temp[i] == 0 && counter == 1)
      {
         x--;
         printf("\nProcess[%d]\t\t%d\t\t %d\t\t\t %d", i + 1, burst_time[i], total - arrival_time[i], total - arrival_time[i] - burst_time[i]);
 
         wait_time = wait_time + total - arrival_time[i] - burst_time[i];
 
         turnaround_time = turnaround_time + total - arrival_time[i];
         counter = 0;
      }
 
      if (i == limit - 1)
      {
         i = 0;
      }
      else if (arrival_time[i + 1] <= total)
      {
         i++;
      }
      else
      {
         i = 0;
      }
   }
 
   average_wait_time = wait_time *1.0 / limit;
   average_turnaround_time = turnaround_time *1.0 / limit;
 
   printf("\n\nAverage Waiting Time:\t%f", average_wait_time);
   printf("\nAvg Turnaround Time:\t%f\n", average_turnaround_time);
 
   return 0;
}

********************* srtf algo *************

#include<stdio.h>

int main()

{

 int at[10],bt[10],rt[10],endTime,i,smallest;

 int remain=0,n,time,sum_wait=0,sum_turnaround=0;

 printf("Enter no of Processes : ");

 scanf("%d",&n);

 for(i=0;i<n;i++)

 {

 printf("Enter arrival time for Process P%d : ",i+1);

 scanf("%d",&at[i]);

 printf("Enter burst time for Process P%d : ",i+1);

 scanf("%d",&bt[i]);

 rt[i]=bt[i];

 }

 printf("\n\nProcess\t|Turnaround Time| Waiting Time\n\n");

 rt[9]=9999;

 for(time=0;remain!=n;time++)

 {

 smallest=9;

 for(i=0;i<n;i++)

 {

 if(at[i]<=time && rt[i]<rt[smallest] && rt[i]>0)

 {

 smallest=i;

 }

 }

 rt[smallest]--;

 if(rt[smallest]==0)

 {

 remain++;

 endTime=time+1;

 printf("\nP[%d]\t|\t%d\t|\t%d",smallest+1,endTime-at[smallest],endTime-bt[smallest]-at[smallest]);

 sum_wait+=endTime-bt[smallest]-at[smallest];

 sum_turnaround+=endTime-at[smallest];

 }

 }

 printf("\n\nAverage waiting time = %f\n",sum_wait*1.0/n);

 printf("Average Turnaround time = %f",sum_turnaround*1.0/5);

 return 0;

}